<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Audio Sample Drop, Playback, and Effects</title>
    <style>
        #drop_zone {
            border: 2px dashed #007bff;
            border-radius: 5px;
            text-align: center;
            margin: 20px;
            position: relative;
            height: 200px;
            box-sizing: border-box;
        }

        #audio_visualizer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: transparent;
        }

        #controls {
            margin: 20px;
            text-align: center;
        }

        label {
            margin-right: 10px;
        }
    </style>
</head>

<body>

    <div id="drop_zone">
        <p>Drag one audio file here to play it.</p>
        <canvas id="audio_visualizer"></canvas>
    </div>
    <div id="controls">
        <label for="pitchSlider">Pitch Control:</label>
        <input type="range" id="pitchSlider" min="0.5" max="2" value="1" step="0.01">
        <label for="grainSizeSlider">Grain Size Control (ms):</label>
        <input type="range" id="grainSizeSlider" min="10" max="1000" value="100" step="10">
    </div>
    <audio id="audio_player" style="width:100%;"></audio>

    <script>
        document.addEventListener('DOMContentLoaded', function () {
            var audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            var sourceNode;
            var dropZone = document.getElementById('drop_zone');
            var pitchSlider = document.getElementById('pitchSlider');
            var grainSizeSlider = document.getElementById('grainSizeSlider');
            var canvas = document.getElementById('audio_visualizer');
            var canvasCtx = canvas.getContext('2d');
            var animationFrameId;
            var startTime = 0; // Start time of the playback
            var offsetTime = 0; // Offset to calculate correct position during pitch changes

            var grainSize = parseFloat(grainSizeSlider.value) / 1000; // size of each grain in seconds
            var grainOverlap = 0.05; // overlap between grains in seconds
            var numGrains = 10;
            var grains = [];

            grainSizeSlider.oninput = function () {
                grainSize = parseFloat(grainSizeSlider.value) / 1000;
                console.log("Grain size: " + grainSize + " seconds");
            };

            function createGrains(buffer) {
                var bufferDuration = buffer.duration;

                function scheduleGrains() {
                    // Clear any previously scheduled grains
                    grains.forEach(grain => grain.stop());
                    grains = [];

                    for (var i = 0; i < numGrains; i++) {
                        let grainSource = audioCtx.createBufferSource();
                        grainSource.buffer = buffer;

                        // Randomize the start position of the grain within the buffer duration
                        let randomStart = Math.random() * (bufferDuration - grainSize);
                        let grainOffset = Math.random() * grainOverlap - grainOverlap / 2; // Randomize offset within overlap range

                        // Calculate the exact start time considering the current context time and offset
                        let exactStartTime = audioCtx.currentTime + i * (grainSize - grainOverlap) + grainOffset;

                        // Ensure start time is non-negative
                        if (exactStartTime < audioCtx.currentTime) {
                            exactStartTime = audioCtx.currentTime;
                        }

                        // Ensure grain does not exceed buffer duration
                        let grainEndTime = Math.min(randomStart + grainSize, bufferDuration);
                        let grainDuration = grainEndTime - randomStart;

                        // Schedule the grain
                        grainSource.start(exactStartTime, randomStart, grainDuration);
                        grainSource.connect(audioCtx.destination);
                        grains.push(grainSource);

                        // Clear the grain after it finishes
                        grainSource.onended = () => {
                            grains = grains.filter(g => g !== grainSource);
                            if (grains.length === 0) {
                                // If all grains are done, reschedule
                                scheduleGrains();
                            }
                        };
                    }
                }

                // Schedule the grains to start
                scheduleGrains();
            }

            function drawWaveform(buffer) {
                var data = buffer.getChannelData(0);
                var step = Math.ceil(data.length / canvas.width);
                var amp = canvas.height / 2;
                canvasCtx.fillStyle = "rgb(200,200,200)";
                canvasCtx.clearRect(0, 0, canvas.width, canvas.height);

                for (var i = 0; i < canvas.width; i++) {
                    var min = 1.0;
                    var max = -1.0;
                    for (var j = 0; j < step; j++) {
                        var datum = data[(i * step) + j];
                        if (datum < min) min = datum;
                        if (datum > max) max = datum;
                    }
                    canvasCtx.fillRect(i, (1 + min) * amp, 1, Math.max(1, (max - min) * amp));
                }
            }

            function updatePlayhead(currentTime, duration) {
                var progress = currentTime / duration;
                var x = progress * canvas.width;
                canvasCtx.strokeStyle = "red";
                canvasCtx.lineWidth = 2;
                canvasCtx.beginPath();
                canvasCtx.moveTo(x, 0);
                canvasCtx.lineTo(x, canvas.height);
                canvasCtx.stroke();
            }

            function animate() {
                if (sourceNode && sourceNode.buffer) {
                    var currentTime = (audioCtx.currentTime - startTime + offsetTime) * sourceNode.playbackRate.value;
                    if (!sourceNode.paused) {
                        canvasCtx.clearRect(0, 0, canvas.width, canvas.height);
                        drawWaveform(sourceNode.buffer);
                        updatePlayhead(currentTime, sourceNode.buffer.duration / sourceNode.playbackRate.value);
                        animationFrameId = requestAnimationFrame(animate);

                        // Calculate and print the playback position in samples
                        var playbackPositionInSamples = currentTime * sourceNode.buffer.sampleRate;
                        console.log("Playback Position (in samples):", playbackPositionInSamples);
                    }
                } else {
                    console.warn("SourceNode is undefined or buffer is not loaded.");
                }
            }

            dropZone.addEventListener('dragover', function (ev) {
                ev.preventDefault();
            });

            dropZone.addEventListener('drop', function (ev) {
                ev.preventDefault();
                if (ev.dataTransfer.items) {
                    var file = ev.dataTransfer.items[0].getAsFile();
                    var reader = new FileReader();
                    reader.onload = function (e) {
                        if (animationFrameId) {
                            cancelAnimationFrame(animationFrameId);
                        }
                        audioCtx.decodeAudioData(e.target.result, function (buffer) {
                            createGrains(buffer);
                            drawWaveform(buffer);
                            animate();
                        });
                    };
                    reader.readAsArrayBuffer(file);
                }
            });

            pitchSlider.oninput = function () {
                var playbackRate = parseFloat(pitchSlider.value);
                if (sourceNode) {
                    var currentTime = (audioCtx.currentTime - startTime + offsetTime);
                    offsetTime = currentTime - (currentTime / playbackRate);
                    sourceNode.playbackRate.value = playbackRate;
                    console.log("Playback rate: " + playbackRate);
                }
            };

            function adjustCanvasSize() {
                canvas.width = dropZone.offsetWidth;
                canvas.height = dropZone.offsetHeight;
            }

            window.addEventListener('load', adjustCanvasSize);
            window.addEventListener('resize', adjustCanvasSize);
        });
    </script>
</body>

</html>
