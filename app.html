<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <title>Audio Sample Drop, Playback, and Effects</title>
    <style>
        #drop_zone {
            border: 2px dashed #007bff;
            border-radius: 5px;
            padding: 20px;
            text-align: center;
            margin: 20px;
            position: relative;
            height: 200px; /* Fixed height for the drop area */
            box-sizing: border-box;
        }
        
        #audio_visualizer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: transparent;
        }
        
        #controls {
            margin: 20px;
            text-align: center;
        }
        
        label {
            margin-right: 10px;
        }
    </style>
</head>
<body>

<div id="drop_zone">
    <p>Drag one audio file here to play it.</p>
    <canvas id="audio_visualizer"></canvas>
</div>
<div id="controls">
    <label for="pitchSlider">Pitch Control:</label>
    <input type="range" id="pitchSlider" min="0.5" max="2" value="1" step="0.01">
</div>

<script>
document.addEventListener('DOMContentLoaded', function() {
    var audioCtx = new (window.AudioContext || window.webkitAudioContext)();
    var sourceNode = null;
    var dropZone = document.getElementById('drop_zone');
    var pitchSlider = document.getElementById('pitchSlider');
    var canvas = document.getElementById('audio_visualizer');
    var canvasCtx = canvas.getContext('2d');
    var duration, lastDrawnAt = 0;

    function drawWaveform(buffer) {
        var data = buffer.getChannelData(0);
        var step = Math.ceil(data.length / canvas.width);
        var amp = canvas.height / 2;
        canvasCtx.fillStyle = "rgb(200,200,200)";
        canvasCtx.clearRect(0, 0, canvas.width, canvas.height);

        for (var i = 0; i < canvas.width; i++) {
            var min = 1.0;
            var max = -1.0;
            for (var j = 0; j < step; j++) {
                var datum = data[(i * step) + j];
                if (datum < min) min = datum;
                if (datum > max) max = datum;
            }
            canvasCtx.fillRect(i, (1 + min) * amp, 1, Math.max(1, (max - min) * amp));
        }
    }

    function animate(playbackRate) {
        if (!sourceNode) return;
        var currentTime = audioCtx.currentTime - sourceNode.startTime;
        var scaledCurrentTime = currentTime * playbackRate;
        if (scaledCurrentTime >= duration || scaledCurrentTime < lastDrawnAt) {
            lastDrawnAt = 0; // Reset for next play
            cancelAnimationFrame(requestId);
            return; // Stop animation when audio ends or if seeking backwards
        }
        
        canvasCtx.clearRect(0, 0, canvas.width, canvas.height);
        drawWaveform(sourceNode.buffer); // Redraw waveform
        updatePlayhead(scaledCurrentTime, duration); // Move playhead
        
        lastDrawnAt = scaledCurrentTime;
        requestId = requestAnimationFrame(() => animate(playbackRate)); // Loop
    }

    function updatePlayhead(currentTime, totalDuration) {
        var progress = currentTime / totalDuration;
        var x = progress * canvas.width;
        canvasCtx.fillStyle = 'rgba(0, 0, 0, 0.5)'; // Playhead color
        canvasCtx.fillRect(x, 0, 2, canvas.height); // Draw playhead
    }

    dropZone.addEventListener('dragover', ev => ev.preventDefault());

    dropZone.addEventListener('drop', function(ev) {
        ev.preventDefault();
        if (ev.dataTransfer.items) {
            var file = ev.dataTransfer.items[0].getAsFile();
            var reader = new FileReader();
            reader.onload = e => {
                audioCtx.decodeAudioData(e.target.result, buffer => {
                    if (sourceNode) sourceNode.disconnect();
                    sourceNode = audioCtx.createBufferSource();
                    sourceNode.buffer = buffer;
                    sourceNode.connect(audioCtx.destination);
                    sourceNode.start(0);
                    sourceNode.startTime = audioCtx.currentTime;
                    duration = buffer.duration;
                    animate(parseFloat(pitchSlider.value)); // Start animation with initial pitch
                });
            };
            reader.readAsArrayBuffer(file);
        }
    });

    pitchSlider.addEventListener('input', () => {
        if (!sourceNode) return;
        var newRate = parseFloat(pitchSlider.value);
        sourceNode.playbackRate.setValueAtTime(newRate, audioCtx.currentTime);
        animate(newRate); // Restart animation with new pitch
    });
});
</script>
</body>
</html>
               
