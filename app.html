<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <title>Audio Sample Drop, Playback, and Effects</title>
    <style>
        body {
            font-family: 'Courier New', Courier, monospace;
            background-color: #222;
            color: #33FF33;
            text-align: center;
            padding: 50px;
        }

        #drop_zone {
            border: 3px dashed #33FF33;
            border-radius: 5px;
            padding: 20px;
            text-align: center;
            margin: 20px auto;
            width: 80%;
            max-width: 600px;
            height: 200px;
            box-sizing: border-box;
            background-color: #111;
            color: #33FF33;
            position: relative;
        }

        #audio_visualizer {
            position: absolute;
            top: 0;
            left: 0;
            width: 100%;
            height: 100%;
            background-color: transparent;
        }

        #controls {
            margin: 20px auto;
            text-align: center;
            width: 80%;
            max-width: 600px;
        }

        label {
            margin-right: 10px;
            color: #33FF33;
        }

        input[type="range"] {
            -webkit-appearance: none;
            width: 100%;
            background: #333;
            cursor: pointer;
        }

        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            appearance: none;
            width: 20px;
            height: 20px;
            background: #33FF33;
            cursor: pointer;
        }

        input[type="range"]::-moz-range-thumb {
            width: 20px;
            height: 20px;
            background: #33FF33;
            cursor: pointer;
        }
    </style>
</head>

<body>

    <div id="drop_zone">
        <p>Drag one audio file here to play it.</p>
        <canvas id="audio_visualizer"></canvas>
    </div>
    <div id="controls">
        <label for="grainSizeSlider">Grain Size Control (ms):</label>
        <input type="range" id="grainSizeSlider" min="10" max="1000" value="100" step="10">
    </div>
    <audio id="audio_player" style="display:none;"></audio>

    <script>
        document.addEventListener('DOMContentLoaded', function () {
            var audioCtx = new (window.AudioContext || window.webkitAudioContext)();
            var dropZone = document.getElementById('drop_zone');
            var grainSizeSlider = document.getElementById('grainSizeSlider');
            var canvas = document.getElementById('audio_visualizer');
            var canvasCtx = canvas.getContext('2d');
            var animationFrameId;
            var grainSize = parseFloat(grainSizeSlider.value) / 1000; // size of each grain in seconds
            var grainOverlap = 0.05; // overlap between grains in seconds
            var numGrains = 10;
            var grains = [];

            grainSizeSlider.oninput = function () {
                grainSize = parseFloat(grainSizeSlider.value) / 1000;
                console.log("Grain size: " + grainSize + " seconds");
            };

            function createGrains(buffer) {
                var bufferDuration = buffer.duration;

                function scheduleGrains() {
                    // Clear any previously scheduled grains
                    grains.forEach(grain => grain.stop());
                    grains = [];

                    for (var i = 0; i < numGrains; i++) {
                        let grainSource = audioCtx.createBufferSource();
                        grainSource.buffer = buffer;

                        // Randomize the start position of the grain within the buffer duration
                        let randomStart = Math.random() * (bufferDuration - grainSize);
                        let grainOffset = Math.random() * grainOverlap - grainOverlap / 2; // Randomize offset within overlap range

                        // Calculate the exact start time considering the current context time and offset
                        let exactStartTime = audioCtx.currentTime + i * (grainSize - grainOverlap) + grainOffset;

                        // Ensure start time is non-negative
                        if (exactStartTime < audioCtx.currentTime) {
                            exactStartTime = audioCtx.currentTime;
                        }

                        // Ensure grain does not exceed buffer duration
                        let grainEndTime = Math.min(randomStart + grainSize, bufferDuration);
                        let grainDuration = grainEndTime - randomStart;

                        // Schedule the grain
                        grainSource.start(exactStartTime, randomStart, grainDuration);
                        grainSource.connect(audioCtx.destination);
                        grains.push(grainSource);

                        // Clear the grain after it finishes
                        grainSource.onended = () => {
                            grains = grains.filter(g => g !== grainSource);
                            if (grains.length === 0) {
                                // If all grains are done, reschedule
                                scheduleGrains();
                            }
                        };
                    }
                }

                // Schedule the grains to start
                scheduleGrains();
            }

            function drawWaveform(buffer) {
                var data = buffer.getChannelData(0);
                var step = Math.ceil(data.length / canvas.width);
                var amp = canvas.height / 2;
                canvasCtx.fillStyle = "#33FF33";
                canvasCtx.clearRect(0, 0, canvas.width, canvas.height);

                for (var i = 0; i < canvas.width; i++) {
                    var min = 1.0;
                    var max = -1.0;
                    for (var j = 0; j < step; j++) {
                        var datum = data[(i * step) + j];
                        if (datum < min) min = datum;
                        if (datum > max) max = datum;
                    }
                    canvasCtx.fillRect(i, (1 + min) * amp, 1, Math.max(1, (max - min) * amp));
                }
            }

            dropZone.addEventListener('dragover', function (ev) {
                ev.preventDefault();
            });

            dropZone.addEventListener('drop', function (ev) {
                ev.preventDefault();
                if (ev.dataTransfer.items) {
                    var file = ev.dataTransfer.items[0].getAsFile();
                    var reader = new FileReader();
                    reader.onload = function (e) {
                        if (animationFrameId) {
                            cancelAnimationFrame(animationFrameId);
                        }
                        audioCtx.decodeAudioData(e.target.result, function (buffer) {
                            createGrains(buffer);
                            drawWaveform(buffer);
                        });
                    };
                    reader.readAsArrayBuffer(file);
                }
            });

            function adjustCanvasSize() {
                canvas.width = dropZone.offsetWidth;
                canvas.height = dropZone.offsetHeight;
            }

            window.addEventListener('load', adjustCanvasSize);
            window.addEventListener('resize', adjustCanvasSize);
        });
    </script>
</body>

</html>
